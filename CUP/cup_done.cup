import java_cup.runtime.*;
import java.io.*;

parser code {:
	public static void main(String args[]) throws Exception {
		try{
		new parser(new Yylex(System.in)).parse();  // Inicializamos el scanner (Yylex) para que 				}							   	   // la entrada sea por teclado   
		}
		catch ( Exception e) {
			System.out.println(" An·lisis INCORRECTO !!");
			System.exit(1);}
		System.out.println("An·lisis Correcto ");
 	}
:}




terminal ESCAPED_QUOTE, LITERAL, COMMA, SEMICOLON, CRLF, REQUIRE, END, DEF, RETURN;
terminal IF, THEN, ELSE, ELSIF, UNLESS, WHILE, RETRY, BREAK, FOR, TRUE, FALSE, PLUS, MINUS;
terminal MUL, DIV, MOD, EXP, EQUAL, NOT_EQUAL, GREATER, LESS, LESS_EQUAL, GREATER_EQUAL;
terminal ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, EXP_ASSIGN;
terminal BIT_AND, BIT_OR, BIT_XOR, BIT_NOT, BIT_SHL, BIT_SHR, AND, OR, NOT, LEFT_RBRACKET;
terminal RIGHT_RBRACKET, LEFT_SBRACKET, RIGHT_SBRACKET, NIL, SL_COMMENT, ML_COMMENT, WS;
terminal INT, FLOAT, ID, ID_GLOBAL, ID_FUNCTION;

non terminal prog, expression_list, expression, require_block, function_definition;
non terminal function_definition_body, function_definition_header, function_name;
non terminal function_definition_params, function_definition_params_list, return_statement;
non terminal function_call, function_call_param_list, function_call_params, if_elsif_statement;
non terminal if_statement, unless_statement, while_statement, while_expression_list;
non terminal for_statement, for_expression_list, assignment, array_assignment, array_definition;
non terminal array_definition_elements, array_selector, int_result, float_result, string_result;
non terminal lvalue, rvalue, literal_t, float_t, int_t, bool_t, nil_t, id, id_global;
non terminal id_function, terminator, crlf;

prog ::= expression_list;
expression_list ::= expression terminator
    | expression_list expression terminator;
expression: function_definition
    | require_block
    | if_statement
    | unless_statement
    | rvalue
    | return_statement
    | while_statement
    | for_statement;
require_block ::= REQUIRE literal_t;
function_definition ::= function_definition_header function_definition_body END;
function_definition_body ::= expression_list;
function_definition_header ::= DEF function_name crlf
    | DEF function_name function_definition_params crlf;
function_name ::= id_function
    | id;
function_definition_params ::= LEFT_RBRACKET function_definition_params_list RIGHT_RBRACKET
    | function_definition_params_list;
function_definition_params_list ::= id
    | function_definition_params_list COMMA id;
return_statement ::= RETURN rvalue;
function_call ::= function_name LEFT_RBRACKET function_call_param_list RIGHT_RBRACKET
    | function_name function_call_param_list
    | function_name LEFT_RBRACKET RIGHT_RBRACKET;
function_call_param_list ::= function_call_params;
function_call_params ::= rvalue
    | function_call_params COMMA rvalue;
if_elsif_state,emt ::= ELSIF rvalue crlf expression_list
    | ELSIF rvalue crlf expression_list ELSE crlf expression_list
    | ELSIF rvalue crlf expression_list if_elsif_statement;
if_statement ::= IF rvalue crlf expression_list END
    | IF rvalue THEN expression_list END
    | IF rvalue crlf expression_list ELSE crlf expression_list END
    | IF rvalue THEN expression_list ELSE expression_list END
    | IF rvalue crlf expression_list if_elsif_statement END;
unless_statement ::= UNLESS rvalue crlf expression_list END;
while_statement ::= WHILE rvalue crlf while_expression_list END;
while_expression_list ::= expression terminator
    | RETRY terminator
    | BREAK terminator
    | while_expression_list expression terminator
    | while_expression_list RETRY terminator
    | while_expression_list BREAK terminator;
for_statement ::= FOR LEFT_RBRACKET expression SEMICOLON expression SEMICOLON expression RIGHT_RBRACKET crlf for_expression_list END
    | FOR expression SEMICOLON expression SEMICOLON expression crlf for_expression_list END
for_expression_list ::= expression terminator
    | RETRY terminator
    | BREAK terminator
    | for_expression_list expression terminator
    | for_expression_list RETRY terminator
    | for_expression_list BREAK terminator;
assignment ::= lvalue ASSIGN rvalue
    | lvalue ( PLUS_ASSIGN | MINUS_ASSIGN | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | EXP_ASSIGN ) rvalue;
array_assignment ::= lvalue array_definition ASSIGN rvalue
    | lvalue ASSIGN array_definition;
array_definition ::= LEFT_SBRACKET array_definition_elements RIGHT_SBRACKET
    | LEFT_SBRACKET RIGHT_SBRACKET;
array_definition_elements ::= rvalue
    | array_definition_elements COMMA rvalue;
array_selector ::= id LEFT_SBRACKET rvalue RIGHT_SBRACKET
    | id_global LEFT_SBRACKET rvalue RIGHT_SBRACKET
    | function_call LEFT_SBRACKET rvalue RIGHT_SBRACKET;
int_result ::= int_result ( MUL | DIV | MOD ) int_result
    | int_result ( PLUS | MINUS ) int_result
    | int_t;
float_result ::= float_result ( MUL | DIV | MOD ) float_result
    | int_result ( MUL | DIV | MOD ) float_result
    | float_result ( MUL | DIV | MOD ) int_result
    | float_result ( PLUS | MINUS ) float_result
    | int_result ( PLUS | MINUS )  float_result
    | float_result ( PLUS | MINUS )  int_result
    | float_t;
string_result ::= string_result MUL int_result
    | int_result MUL string_result
    | literal_t;
lvalue ::= id
    | id_global;
rvalue ::= lvalue
    | array_assignment
    | int_result
    | float_result
    | string_result
    | assignment
    | function_call
    | literal_t
    | bool_t
    | float_t
    | int_t
    | nil_t
    | rvalue EXP rvalue
    | ( NOT | BIT_NOT )rvalue
    | rvalue ( MUL | DIV | MOD ) rvalue
    | rvalue ( PLUS | MINUS ) rvalue
    | rvalue ( BIT_SHL | BIT_SHR ) rvalue
    | rvalue BIT_AND rvalue
    | rvalue ( BIT_OR | BIT_XOR )rvalue
    | rvalue ( LESS | GREATER | LESS_EQUAL | GREATER_EQUAL ) rvalue
    | rvalue ( EQUAL | NOT_EQUAL ) rvalue
    | rvalue ( OR | AND ) rvalue
    | LEFT_RBRACKET rvalue RIGHT_RBRACKET;
literal_t ::= LITERAL;
float_t ::= FLOAT;
int_t ::= INT;
bool_t ::= TRUE
    | FALSE;
nil_t ::= NIL;
id ::= ID;
id_global ::= ID_GLOBAL;
id_function ::= ID_FUNCTION;
terminator ::= terminator SEMICOLON
    | terminator crlf
    | SEMICOLON
    | crlf;
crlf ::= CRLF;