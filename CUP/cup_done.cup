import java_cup.runtime.*;


action code {:
    private final int PLUS = 1;
    private final int MINUS = 2;
    private final int DIV = 3;
    private final int MUL = 4;
    private final int EXP = 5;
    private final int MOD = 6;

    private VarInfo calcVarInfo_int_result(VarInfo num1, VarInfo num2, int operator){
        if(num1.getType() == VarInfo.ERROR && num2.getType() == VarInfo.ERROR)
           return new VarInfo(VarInfo.ERROR, (String)num1.getContent() + "; " + (String)num2.getContent());
        else if(num1.getType() == VarInfo.ERROR)
           return num1;
        else if(num2.getType() == VarInfo.ERROR)
           return num2;
        else{
           int int_result = 0;
           switch(operator){
              case MUL:
                  int_result = (int)num1.getContent() * (int)num2.getContent();
                  break;
              case DIV:
                  if((int)num2.getContent() == 0){
                      System.out.println("Zero division");
                      return new VarInfo(VarInfo.ERROR, "Zero division");
                  }
                  int_result = (int)num1.getContent() / (int)num2.getContent();
                  break;
              case PLUS:
                  int_result = (int)num1.getContent() + (int)num2.getContent();
                  break;
              case MINUS:
                  int_result = (int)num1.getContent() - (int)num2.getContent();
                  break;
              case MOD:
                  int_result = (int)num1.getContent() % (int)num2.getContent();
                  break;
              case EXP:
                  int_result = (int)Math.pow((int)num1.getContent(), (int)num2.getContent());
                  break;
           }
           return new VarInfo(VarInfo.INT_TYPE, int_result);
        }
      }


      private VarInfo calcVarInfo_float_result(VarInfo num1, VarInfo num2, int operator){
          if(num1.getType() == VarInfo.ERROR && num2.getType() == VarInfo.ERROR)
             return new VarInfo(VarInfo.ERROR, (String)num1.getContent() + "; " + (String)num2.getContent());
          else if(num1.getType() == VarInfo.ERROR)
             return num1;
          else if(num2.getType() == VarInfo.ERROR)
             return num2;
          else{
             double float_result = 0;
             double op1 = ((Number) num1.getContent()).doubleValue();
             double op2 = ((Number) num2.getContent()).doubleValue();
             switch(operator){
                case MUL:
                    float_result = op1 * op2;
                    break;
                case DIV:
                    if(op2 == 0){
                        System.out.println("Zero division");
                        return new VarInfo(VarInfo.ERROR, "Zero division");
                    }
                    float_result = op1 / op2;
                    break;
                case PLUS:
                    float_result = op1 + op2;
                    break;
                case MINUS:
                    float_result = op1 - op2;
                    break;
                case MOD:
                    float_result = op1 % op2;
                    break;
                case EXP:
                    float_result = Math.pow(op1, op2);
                    break;
             }
             return new VarInfo(VarInfo.FLOAT_TYPE, float_result);
          }
        }

        public VarInfo calcVarInfo_string_result(VarInfo str, VarInfo num){
            if(str.getType() == VarInfo.ERROR && num.getType() == VarInfo.ERROR)
                    return new VarInfo(VarInfo.ERROR, (String)str.getContent() + "; " + (String)num.getContent());
               else if(num.getType() == VarInfo.ERROR)
                    return num;
               else if(str.getType() == VarInfo.ERROR)
                    return str;
               else{
                  int reps = (int)num.getContent();
                  if(reps < 0){
                     System.out.println("Negative Argument");
                     return new VarInfo(VarInfo.ERROR, "Negative Argument");
                  }
                  else{
                      String s = (String)str.getContent();
                      String result = "";
                      for(int i=0;i<reps;i++)
                         result += s;
                      return new VarInfo(VarInfo.STRING_TYPE, result);
                  }
              }
        }
:}


/* Terminals  (tokens returned by the scanner). */
terminal String LITERAL;
terminal Integer INT;
terminal Double FLOAT;
terminal Boolean TRUE, FALSE;
terminal COMMA, SEMICOLON, CRLF, REQUIRE, END, DEF, RETURN, IF, THEN, ELSE, ELSIF, UNLESS, WHILE, RETRY, BREAK, FOR, PLUS, MINUS, MUL, DIV, MOD, EXP, EQUAL, NOT_EQUAL, GREATER, LESS, LESS_EQUAL, GREATER_EQUAL, ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, EXP_ASSIGN, BIT_AND, BIT_OR, BIT_XOR, BIT_NOT, BIT_SHL, BIT_SHR, AND, OR, NOT, LEFT_RBRACKET, RIGHT_RBRACKET, LEFT_SBRACKET, RIGHT_SBRACKET, NIL, ID, ID_GLOBAL, ID_FUNCTION;

/* Non terminals */
non terminal VarInfo rvalue, int_result, float_result, string_result;
non terminal Integer int_t;
non terminal Double float_t;
non terminal prog, expression_list, expression, require_block, function_definition, function_definition_body, function_definition_header, function_name, function_definition_params, function_definition_params_list, return_statement, function_call, function_call_param_list, function_call_params, if_elsif_statement, if_statement, unless_statement, while_statement, while_expression_list, for_statement, for_expression_list, assignment, array_assignment, array_definition, array_definition_elements, array_selector, lvalue, literal_t, bool_t, nil_t, id, id_global, id_function, terminator, crlf;

/* Precedences based in http://stackoverflow.com/questions/21060234/ruby-operator-precedence-table */
precedence right PLUS_ASSIGN, MINUS_ASSIGN, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, EXP_ASSIGN;
precedence right ASSIGN;
precedence left OR;
precedence left AND;
precedence nonassoc EQUAL, NOT_EQUAL, GREATER, LESS, LESS_EQUAL, GREATER_EQUAL;
precedence left BIT_OR, BIT_XOR;
precedence left BIT_AND;
precedence left BIT_SHR, BIT_SHL;
precedence left PLUS, MINUS;
precedence left MUL, DIV, MOD;
precedence right EXP;



prog ::= expression_list;

expression_list ::= expression terminator
    		  | expression_list expression terminator;

expression ::= function_definition
    		  | require_block
  		  	| if_statement
 	        | unless_statement
    			| rvalue:result                                    {: System.out.println(result); :}
    			| return_statement
    			| while_statement
    			| for_statement;

require_block ::= REQUIRE literal_t;

function_definition ::= function_definition_header function_definition_body END;

function_definition_body ::= expression_list;

function_definition_header ::= DEF function_name crlf
    			| DEF function_name function_definition_params crlf;

function_name ::= id_function
    			| id;

function_definition_params ::= LEFT_RBRACKET function_definition_params_list RIGHT_RBRACKET
    			| function_definition_params_list;

function_definition_params_list ::= id
    		  | function_definition_params_list COMMA id;

return_statement ::= RETURN rvalue;

function_call ::= function_name LEFT_RBRACKET function_call_param_list RIGHT_RBRACKET
			    | function_name function_call_param_list
			    | function_name LEFT_RBRACKET RIGHT_RBRACKET;

function_call_param_list ::= function_call_params;

function_call_params ::= rvalue
					| function_call_params COMMA rvalue;

if_elsif_statement ::= ELSIF rvalue crlf expression_list
					| ELSIF rvalue crlf expression_list ELSE crlf expression_list
					| ELSIF rvalue crlf expression_list if_elsif_statement;

if_statement ::= IF rvalue crlf expression_list END
			    | IF rvalue THEN expression_list END
			    | IF rvalue crlf expression_list ELSE crlf expression_list END
			    | IF rvalue THEN expression_list ELSE expression_list END
			    | IF rvalue crlf expression_list if_elsif_statement END;

unless_statement ::= UNLESS rvalue crlf expression_list END;

while_statement ::= WHILE rvalue crlf while_expression_list END;

while_expression_list ::= expression terminator
			    | RETRY terminator
			    | BREAK terminator
			    | while_expression_list expression terminator
			    | while_expression_list RETRY terminator
			    | while_expression_list BREAK terminator;

for_statement ::= FOR LEFT_RBRACKET expression SEMICOLON expression SEMICOLON expression
 											RIGHT_RBRACKET crlf for_expression_list END
    			| FOR expression SEMICOLON expression SEMICOLON expression crlf for_expression_list END;

for_expression_list ::= expression terminator
			    | RETRY terminator
			    | BREAK terminator
			    | for_expression_list expression terminator
			    | for_expression_list RETRY terminator
			    | for_expression_list BREAK terminator;

assignment ::= lvalue ASSIGN rvalue
			    | lvalue PLUS_ASSIGN rvalue
					| lvalue MINUS_ASSIGN rvalue
					| lvalue MUL_ASSIGN rvalue
					| lvalue DIV_ASSIGN rvalue
					| lvalue MOD_ASSIGN rvalue
					| lvalue EXP_ASSIGN rvalue;

array_assignment ::= lvalue array_definition ASSIGN rvalue
    			| lvalue ASSIGN array_definition;

array_definition ::= LEFT_SBRACKET array_definition_elements RIGHT_SBRACKET
    			| LEFT_SBRACKET RIGHT_SBRACKET;

array_definition_elements ::= rvalue
    			| array_definition_elements COMMA rvalue;

array_selector ::= id LEFT_SBRACKET rvalue RIGHT_SBRACKET
			    | id_global LEFT_SBRACKET rvalue RIGHT_SBRACKET
			    | function_call LEFT_SBRACKET rvalue RIGHT_SBRACKET;

int_result ::= int_result:num1 MUL int_result:num2
          {:
             RESULT = calcVarInfo_int_result(num1, num2, MUL);
          :}
					| int_result:num1 DIV int_result:num2
          {:
             RESULT = calcVarInfo_int_result(num1, num2, DIV);
           :}
					| int_result:num1 MOD int_result:num2
          {:
             RESULT = calcVarInfo_int_result(num1, num2, MOD);
          :}
			    | int_result:num1 PLUS int_result:num2
          {:
             RESULT = calcVarInfo_int_result(num1, num2, PLUS);
          :}
					| int_result:num1 MINUS int_result:num2
          {:
             RESULT = calcVarInfo_int_result(num1, num2, MINUS);
          :}
          | int_result:num1 EXP int_result:num2
          {:
             RESULT = calcVarInfo_int_result(num1, num2, EXP);
          :}
          | LEFT_RBRACKET int_result:num RIGHT_RBRACKET
          {:
             RESULT = num;
          :}
			    | int_t:num
          {:
             RESULT = new VarInfo(VarInfo.INT_TYPE, num);
          :};

float_result ::= float_result:num1 MUL float_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, MUL);
          :}
					| float_result:num1 DIV float_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, DIV);
          :}
					| float_result:num1 MOD float_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, MOD);
          :}
			    | int_result:num1 MUL float_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, MUL);
          :}
					| int_result:num1 DIV float_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, DIV);
          :}
					| int_result:num1 MOD float_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, MOD);
          :}
			    | float_result:num1 MUL int_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, MUL);
          :}
					| float_result:num1 DIV int_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, DIV);
          :}
					| float_result:num1 MOD int_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, MOD);
          :}
			    | float_result:num1 PLUS float_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, PLUS);
          :}
					| float_result:num1 MINUS float_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, MINUS);
          :}
			    | int_result:num1 PLUS float_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, PLUS);
          :}
					| int_result:num1 MINUS float_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, MINUS);
          :}
			    | float_result:num1 PLUS int_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, PLUS);
          :}
					| float_result:num1 MINUS int_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, MINUS);
          :}
          | float_result:num1 EXP float_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, EXP);
          :}
          | int_result:num1 EXP float_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, EXP);
          :}
          | float_result:num1 EXP int_result:num2
          {:
             RESULT = calcVarInfo_float_result(num1, num2, EXP);
          :}
          | LEFT_RBRACKET float_result:num RIGHT_RBRACKET
          {:
             RESULT = num;
          :}
			    | float_t:num
          {:
             RESULT = new VarInfo(VarInfo.FLOAT_TYPE, num);
          :};

string_result ::= string_result:str MUL int_result:num
          {:
            RESULT = calcVarInfo_string_result(str, num);
          :}
    			| int_result:num MUL string_result:str
          {:
            RESULT = calcVarInfo_string_result(str, num);
          :}
    			| literal_t:str
          {:
            RESULT = new VarInfo(VarInfo.STRING_TYPE, str);
          :};

lvalue ::= id
    			| id_global;

rvalue ::= lvalue
					| int_result:num
          {: RESULT = num; :}
				  | float_result:num
          {: RESULT = num; :}
					| string_result:str
          {: RESULT = str; :}
					| assignment
					| bool_t
					| nil_t
					| NOT rvalue
					| BIT_NOT rvalue
					| rvalue BIT_SHL rvalue
					| rvalue BIT_SHR rvalue
					| rvalue BIT_AND rvalue
					| rvalue BIT_OR rvalue
					| rvalue BIT_XOR rvalue
					| rvalue LESS rvalue
					| rvalue GREATER rvalue
					| rvalue LESS_EQUAL rvalue
					| rvalue GREATER_EQUAL rvalue
					| rvalue EQUAL rvalue
					| rvalue NOT_EQUAL rvalue
					| rvalue OR rvalue
					| rvalue AND rvalue
					;

literal_t ::= LITERAL:str                                 {: RESULT = str; :};

float_t ::= FLOAT:num                                     {: RESULT = num; :};

int_t ::= INT:num                                         {: RESULT = num; :};

bool_t ::= TRUE
		| FALSE;

nil_t ::= NIL;

id ::= ID;

id_global ::= ID_GLOBAL;

id_function ::= ID_FUNCTION;

terminator ::= terminator SEMICOLON
				| terminator crlf
				| SEMICOLON
				| crlf;

crlf ::= CRLF;
