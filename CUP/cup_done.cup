import java_cup.runtime.*;
import java.util.Hashtable;


action code {:
  Hashtable<String, VarInfo> varTable = new Hashtable<String,VarInfo>();

	private final int PLUS = 1;
	private final int MINUS = 2;
	private final int DIV = 3;
	private final int MUL = 4;
	private final int EXP = 5;
	private final int MOD = 6;

	private VarInfo calcVarInfo_int_result(VarInfo num1, VarInfo num2, int operator){
		if(num1.getType() == VarInfo.ERROR && num2.getType() == VarInfo.ERROR)
			return new VarInfo(VarInfo.ERROR, (String)num1.getContent() + "; " + (String)num2.getContent());
		else if(num1.getType() == VarInfo.ERROR)
			return num1;
		else if(num2.getType() == VarInfo.ERROR)
			return num2;
		else{
			int int_result = 0;
			switch(operator){
				case MUL:
				int_result = (int)num1.getContent() * (int)num2.getContent();
				break;
				case DIV:
					if((int)num2.getContent() == 0){
						return new VarInfo(VarInfo.ERROR, "Zero division");
					}
					int_result = (int)num1.getContent() / (int)num2.getContent();
					break;
				case PLUS:
					int_result = (int)num1.getContent() + (int)num2.getContent();
				break;
				case MINUS:
					int_result = (int)num1.getContent() - (int)num2.getContent();
				break;
				case MOD:
					int_result = (int)num1.getContent() % (int)num2.getContent();
				break;
				case EXP:
					int_result = (int)Math.pow((int)num1.getContent(), (int)num2.getContent());
				break;
	        	}
		return new VarInfo(VarInfo.INT_TYPE, int_result);
		}
	}


      private VarInfo calcVarInfo_float_result(VarInfo num1, VarInfo num2, int operator){
          if(num1.getType() == VarInfo.ERROR && num2.getType() == VarInfo.ERROR)
             return new VarInfo(VarInfo.ERROR, (String)num1.getContent() + "; " + (String)num2.getContent());
          else if(num1.getType() == VarInfo.ERROR)
             return num1;
          else if(num2.getType() == VarInfo.ERROR)
             return num2;
          else{
             double float_result = 0;
             double op1 = ((Number) num1.getContent()).doubleValue();
             double op2 = ((Number) num2.getContent()).doubleValue();
             switch(operator){
                case MUL:
                    float_result = op1 * op2;
                    break;
                case DIV:
                    if(op2 == 0){
                        return new VarInfo(VarInfo.ERROR, "Zero division");
                    }
                    float_result = op1 / op2;
                    break;
                case PLUS:
                    float_result = op1 + op2;
                    break;
                case MINUS:
                    float_result = op1 - op2;
                    break;
                case MOD:
                    float_result = op1 % op2;
                    break;
                case EXP:
                    float_result = Math.pow(op1, op2);
                    break;
             }
             return new VarInfo(VarInfo.FLOAT_TYPE, float_result);
          }
        }

        public VarInfo calcVarInfo_string_result(VarInfo str, VarInfo num){
            if(str.getType() == VarInfo.ERROR && num.getType() == VarInfo.ERROR)
                    return new VarInfo(VarInfo.ERROR, (String)str.getContent() + "; " + (String)num.getContent());
               else if(num.getType() == VarInfo.ERROR)
                    return num;
               else if(str.getType() == VarInfo.ERROR)
                    return str;
               else{
                  int reps = (int)num.getContent();
                  if(reps < 0){
                     return new VarInfo(VarInfo.ERROR, "Negative Argument");
                  }
                  else{
                      String s = (String)str.getContent();
                      String result = "";
                      for(int i=0;i<reps;i++)
                         result += s;
                      return new VarInfo(VarInfo.STRING_TYPE, result);
                  }
              }
        }

        public VarInfo checkVarError(VarInfo var1, VarInfo var2){
            VarInfo result = null;
            if(var1.getType() == VarInfo.ERROR && var2.getType() == VarInfo.ERROR)
              result = new VarInfo(VarInfo.ERROR, (String)var1.getContent() + "; " + (String)var2.getContent());
            else if(var1.getType() == VarInfo.ERROR)
               result = var1;
            else if(var2.getType() == VarInfo.ERROR)
               result = var2;
            return result;
        }


        public boolean checkIncompatibleType(VarInfo var1, VarInfo var2){
          if(var1.getType() == var2.getType() || (var1.getType() == VarInfo.INT_TYPE || var1.getType() == VarInfo.FLOAT_TYPE) && (var2.getType() == VarInfo.INT_TYPE || var2.getType() == VarInfo.FLOAT_TYPE))
              return false;
          return true;
        }

        public int calcVariInfo_compare(VarInfo var1, VarInfo var2){
          if(var1.getType() == VarInfo.NIL_TYPE && var2.getType() == VarInfo.NIL_TYPE)
            return 0;
          else if((var1.getType() == VarInfo.INT_TYPE || var1.getType() == VarInfo.FLOAT_TYPE) && (var2.getType() == VarInfo.INT_TYPE || var2.getType() == VarInfo.FLOAT_TYPE)){
            Comparable v1 = (Comparable)((Number) var1.getContent()).doubleValue();
            Comparable v2 = (Comparable)((Number) var2.getContent()).doubleValue();
            return v1.compareTo(v2);
          }
          else{
            Comparable v1 = (Comparable) var1.getContent();
            Comparable v2 = (Comparable) var2.getContent();
            return v1.compareTo(v2);
          }
        }
:}


/* Terminals  (tokens returned by the scanner). */
terminal String LITERAL, NIL, ID, ID_GLOBAL;
terminal Integer INT;
terminal Double FLOAT;
terminal Boolean TRUE, FALSE;
terminal COMMA, SEMICOLON, CRLF, REQUIRE, END, DEF, RETURN, IF, THEN, ELSE, ELSIF, UNLESS, WHILE, RETRY, BREAK, FOR, PLUS, MINUS, MUL, DIV, MOD, EXP, EQUAL, NOT_EQUAL, GREATER, LESS, LESS_EQUAL, GREATER_EQUAL, ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, EXP_ASSIGN, BIT_AND, BIT_OR, BIT_XOR, BIT_NOT, BIT_SHL, BIT_SHR, AND, OR, NOT, LEFT_RBRACKET, RIGHT_RBRACKET, LEFT_SBRACKET, RIGHT_SBRACKET, ID_FUNCTION;

/* Non terminals */
non terminal VarInfo rvalue, int_result, float_result, string_result, nil_t, literal_t, bool_t, int_t, float_t, assignment;
non terminal String lvalue, id, id_global;
non terminal prog, expression_list, expression, require_block, function_definition, function_definition_body, function_definition_header, function_name, function_definition_params, function_definition_params_list, return_statement, function_call, function_call_param_list, function_call_params, if_elsif_statement, if_statement, unless_statement, while_statement, while_expression_list, for_statement, for_expression_list, array_assignment, array_definition, array_definition_elements, array_selector, id_function, terminator, crlf;

/* Precedences based in http://stackoverflow.com/questions/21060234/ruby-operator-precedence-table */
precedence right PLUS_ASSIGN, MINUS_ASSIGN, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, EXP_ASSIGN;
precedence right ASSIGN;
precedence left OR;
precedence left AND;
precedence nonassoc EQUAL, NOT_EQUAL, GREATER, LESS, LESS_EQUAL, GREATER_EQUAL;
precedence left BIT_OR, BIT_XOR;
precedence left BIT_AND;
precedence left BIT_SHR, BIT_SHL;
precedence left PLUS, MINUS;
precedence left MUL, DIV, MOD;
precedence right EXP;



prog ::= expression_list;

expression_list ::= expression terminator
    		  | expression_list expression terminator;

expression ::= rvalue:result                               {: System.out.println(result); :};



assignment ::= lvalue:var ASSIGN rvalue:value
          {: varTable.put(var, value);
             RESULT = value;
          :}
          | lvalue:var PLUS_ASSIGN rvalue
					| lvalue MINUS_ASSIGN rvalue
					| lvalue MUL_ASSIGN rvalue
					| lvalue DIV_ASSIGN rvalue
					| lvalue MOD_ASSIGN rvalue
					| lvalue EXP_ASSIGN rvalue;


string_result ::= string_result:str MUL int_result:num
          {:
            RESULT = calcVarInfo_string_result(str, num);
          :}
    			| int_result:num MUL string_result:str
          {:
            RESULT = calcVarInfo_string_result(str, num);
          :}
    			| literal_t:str
          {:
            RESULT = str;
          :};

lvalue ::= id:val
          {: RESULT = val; :}
    			| id_global:val
          {: RESULT = val; :};

rvalue ::= lvalue:var
          {: 
            if(varTable.containsKey(var))
               RESULT = varTable.get(var);
             else
                RESULT = new VarInfo(VarInfo.ERROR, "Error: Variable sin inicializar");
          :}
          | literal_t:str
          {:
            RESULT = str;
          :}
					| assignment:var
          {: RESULT = var; :}
					| bool_t:var
          {: RESULT = var; :}
					| nil_t:var
          {: RESULT = var; :}
          | float_t:num
          {:
             RESULT = num;
          :}
          | int_t:num
          {:
             RESULT = num;
          :}
					| NOT rvalue:var
           {:
             if(var.getType() == VarInfo.ERROR)
               RESULT = var;
             else{
               if(var.getType() == VarInfo.NIL_TYPE || var.getType() == VarInfo.BOOL_TYPE && !((Boolean)var.getContent()).booleanValue())
                 RESULT = new VarInfo(VarInfo.BOOL_TYPE, true);
               else
                 RESULT = new VarInfo(VarInfo.BOOL_TYPE, false);
             }
           :}
					| BIT_NOT rvalue
					| rvalue BIT_SHL rvalue
					| rvalue BIT_SHR rvalue
					| rvalue BIT_AND rvalue
					| rvalue BIT_OR rvalue
					| rvalue BIT_XOR rvalue
          | rvalue:var1 PLUS rvalue:var2
          {:
            VarInfo varError = checkVarError(var1, var2);
            if(varError != null)
              RESULT = varError;
            else if(var1.getType() == VarInfo.INT_TYPE && var2.getType() == VarInfo.INT_TYPE)
              RESULT = calcVarInfo_int_result(var1, var2, PLUS);
            else if((var1.getType() == VarInfo.INT_TYPE || var1.getType() == VarInfo.FLOAT_TYPE) && (var2.getType() == VarInfo.INT_TYPE || var2.getType() == VarInfo.FLOAT_TYPE))
              RESULT = calcVarInfo_float_result(var1, var2, PLUS);
            else if(var1.getType() == VarInfo.STRING_TYPE && var2.getType() == VarInfo.STRING_TYPE)
              RESULT = new VarInfo(VarInfo.STRING_TYPE, (String)var1.getContent() + (String)var2.getContent());
            else
              RESULT = new VarInfo(VarInfo.ERROR, "Tipos incompatibles");
          :}
          | rvalue:var1 MINUS rvalue:var2
          {:
            VarInfo varError = checkVarError(var1, var2);
            if(varError != null)
              RESULT = varError;
            else if(var1.getType() == VarInfo.INT_TYPE && var2.getType() == VarInfo.INT_TYPE)
              RESULT = calcVarInfo_int_result(var1, var2, MINUS);
            else if((var1.getType() == VarInfo.INT_TYPE || var1.getType() == VarInfo.FLOAT_TYPE) && (var2.getType() == VarInfo.INT_TYPE || var2.getType() == VarInfo.FLOAT_TYPE))
              RESULT = calcVarInfo_float_result(var1, var2, MINUS);
            else
              RESULT = new VarInfo(VarInfo.ERROR, "Tipos incompatibles");
          :}
          | rvalue:var1 MUL rvalue:var2
          {:
            VarInfo varError = checkVarError(var1, var2);
            if(varError != null)
              RESULT = varError;
            else if(var1.getType() == VarInfo.INT_TYPE && var2.getType() == VarInfo.INT_TYPE)
              RESULT = calcVarInfo_int_result(var1, var2, MUL);
            else if((var1.getType() == VarInfo.INT_TYPE || var1.getType() == VarInfo.FLOAT_TYPE) && (var2.getType() == VarInfo.INT_TYPE || var2.getType() == VarInfo.FLOAT_TYPE))
              RESULT = calcVarInfo_float_result(var1, var2, MUL);
            else if(var1.getType() == VarInfo.STRING_TYPE && var2.getType() == VarInfo.INT_TYPE)
              RESULT = calcVarInfo_string_result(var1, var2);
            else if(var1.getType() == VarInfo.INT_TYPE && var2.getType() == VarInfo.STRING_TYPE)
              RESULT = calcVarInfo_string_result(var2, var1);
            else
              RESULT = new VarInfo(VarInfo.ERROR, "Tipos incompatibles");
          :}
          | rvalue:var1 DIV rvalue:var2
          {:
            VarInfo varError = checkVarError(var1, var2);
            if(varError != null)
              RESULT = varError;
            else if(var1.getType() == VarInfo.INT_TYPE && var2.getType() == VarInfo.INT_TYPE)
              RESULT = calcVarInfo_int_result(var1, var2, DIV);
            else if((var1.getType() == VarInfo.INT_TYPE || var1.getType() == VarInfo.FLOAT_TYPE) && (var2.getType() == VarInfo.INT_TYPE || var2.getType() == VarInfo.FLOAT_TYPE))
              RESULT = calcVarInfo_float_result(var1, var2, DIV);
            else
              RESULT = new VarInfo(VarInfo.ERROR, "Tipos incompatibles");
          :}
          | rvalue:var1 MOD rvalue:var2
          {:
            VarInfo varError = checkVarError(var1, var2);
            if(varError != null)
              RESULT = varError;
            else if(var1.getType() == VarInfo.INT_TYPE && var2.getType() == VarInfo.INT_TYPE)
              RESULT = calcVarInfo_int_result(var1, var2, MOD);
            else if((var1.getType() == VarInfo.INT_TYPE || var1.getType() == VarInfo.FLOAT_TYPE) && (var2.getType() == VarInfo.INT_TYPE || var2.getType() == VarInfo.FLOAT_TYPE))
              RESULT = calcVarInfo_float_result(var1, var2, MOD);
            else
              RESULT = new VarInfo(VarInfo.ERROR, "Tipos incompatibles");
          :}
					| rvalue:var1 LESS rvalue:var2
          {:
            VarInfo varError = checkVarError(var1, var2);
            if(varError != null)
              RESULT = varError;
            else
              if(checkIncompatibleType(var1, var2))
                RESULT = new VarInfo(VarInfo.ERROR, "Tipos incompatibles para comparar.");
              else{
                boolean result = calcVariInfo_compare(var1, var2) < 0;
                RESULT =  new VarInfo(VarInfo.BOOL_TYPE, result);
            }
          :}
					| rvalue:var1 GREATER rvalue:var2
          {:
            VarInfo varError = checkVarError(var1, var2);
            if(varError != null)
              RESULT = varError;
            else
              if(checkIncompatibleType(var1, var2))
                RESULT = new VarInfo(VarInfo.ERROR, "Tipos incompatibles para comparar.");
              else{
                boolean result = calcVariInfo_compare(var1, var2) > 0;
                RESULT =  new VarInfo(VarInfo.BOOL_TYPE, result);
            }
          :}
					| rvalue:var1 LESS_EQUAL rvalue:var2
          {:
            VarInfo varError = checkVarError(var1, var2);
            if(varError != null)
              RESULT = varError;
            else
              if(checkIncompatibleType(var1, var2))
                RESULT = new VarInfo(VarInfo.ERROR, "Tipos incompatibles para comparar.");
              else{
                boolean result = calcVariInfo_compare(var1, var2) <= 0;
                RESULT =  new VarInfo(VarInfo.BOOL_TYPE, result);
            }
          :}
					| rvalue:var1 GREATER_EQUAL rvalue:var2
          {:
            VarInfo varError = checkVarError(var1, var2);
            if(varError != null)
              RESULT = varError;
            else
              if(checkIncompatibleType(var1, var2))
                RESULT = new VarInfo(VarInfo.ERROR, "Tipos incompatibles para comparar.");
              else{
                boolean result = calcVariInfo_compare(var1, var2) >= 0;
                RESULT =  new VarInfo(VarInfo.BOOL_TYPE, result);
            }
          :}
					| rvalue:var1 EQUAL rvalue:var2
          {:
            VarInfo varError = checkVarError(var1, var2);
            if(varError != null)
              RESULT = varError;
            else
              if(checkIncompatibleType(var1, var2))
                RESULT = new VarInfo(VarInfo.ERROR, "Tipos incompatibles para comparar.");
              else{
                boolean result = calcVariInfo_compare(var1, var2) == 0;
                RESULT =  new VarInfo(VarInfo.BOOL_TYPE, result);
            }
          :}
					| rvalue:var1 NOT_EQUAL rvalue:var2
          {:
            VarInfo varError = checkVarError(var1, var2);
            if(varError != null)
              RESULT = varError;
            else
              if(checkIncompatibleType(var1, var2))
                RESULT = new VarInfo(VarInfo.ERROR, "Tipos incompatibles para comparar.");
              else{
                boolean result = calcVariInfo_compare(var1, var2) != 0;
                RESULT =  new VarInfo(VarInfo.BOOL_TYPE, result);
            }
          :}
					| rvalue:var1 OR rvalue:var2
          {:
            VarInfo varError = checkVarError(var1, var2);
            if(varError != null)
              RESULT = varError;
            else{
              if(var1.getType() == VarInfo.NIL_TYPE || var1.getType() == VarInfo.BOOL_TYPE && !((Boolean)var1.getContent()).booleanValue())
                RESULT = var2;
              else
                RESULT = var1;
            }
          :}
					| rvalue:var1 AND rvalue:var2
          {:
            VarInfo varError = checkVarError(var1, var2);
            if(varError != null)
              RESULT = varError;
            else{
              if(var1.getType() == VarInfo.NIL_TYPE || var1.getType() == VarInfo.BOOL_TYPE && !((Boolean)var1.getContent()).booleanValue())
                RESULT = var1;
              else
                RESULT = var2;
            }
          :}
          | LEFT_RBRACKET rvalue:val RIGHT_RBRACKET
          {:
            RESULT = val;
          :}
					;

literal_t ::= LITERAL:str
{: RESULT = new VarInfo(VarInfo.STRING_TYPE, str); :};

float_t ::= FLOAT:num
{: RESULT = new VarInfo(VarInfo.FLOAT_TYPE, num); :};

int_t ::= INT:num
{: RESULT = new VarInfo(VarInfo.INT_TYPE, num); :};

bool_t ::= TRUE
{: RESULT = new VarInfo(VarInfo.BOOL_TYPE, true); :}
| FALSE
{: RESULT = new VarInfo(VarInfo.BOOL_TYPE, false); :};

nil_t ::= NIL:nil
{: RESULT = new VarInfo(VarInfo.NIL_TYPE, nil); :};

id ::= ID:var
{: RESULT = var; :};

id_global ::= ID_GLOBAL:var
{: RESULT = var; :};

terminator ::= terminator SEMICOLON
				| terminator crlf
				| SEMICOLON
				| crlf;

crlf ::= CRLF;
